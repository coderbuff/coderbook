<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>配置 | CoderBook</title>
    <meta name="description" content="CoderBook">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/coderbook/assets/css/0.styles.b2da8d00.css" as="style"><link rel="preload" href="/coderbook/assets/js/app.bd0e8773.js" as="script"><link rel="preload" href="/coderbook/assets/js/2.2e9b2f22.js" as="script"><link rel="preload" href="/coderbook/assets/js/23.d28e9e5c.js" as="script"><link rel="prefetch" href="/coderbook/assets/js/10.6f377ed6.js"><link rel="prefetch" href="/coderbook/assets/js/11.f34c1c50.js"><link rel="prefetch" href="/coderbook/assets/js/12.d8b974da.js"><link rel="prefetch" href="/coderbook/assets/js/13.4f10c2cc.js"><link rel="prefetch" href="/coderbook/assets/js/14.07641015.js"><link rel="prefetch" href="/coderbook/assets/js/15.11341f4e.js"><link rel="prefetch" href="/coderbook/assets/js/16.a1027f62.js"><link rel="prefetch" href="/coderbook/assets/js/17.b0b7317a.js"><link rel="prefetch" href="/coderbook/assets/js/18.42995780.js"><link rel="prefetch" href="/coderbook/assets/js/19.e405f35e.js"><link rel="prefetch" href="/coderbook/assets/js/20.f13e781b.js"><link rel="prefetch" href="/coderbook/assets/js/21.ecee6efb.js"><link rel="prefetch" href="/coderbook/assets/js/22.a5802306.js"><link rel="prefetch" href="/coderbook/assets/js/24.0abc3809.js"><link rel="prefetch" href="/coderbook/assets/js/25.6a2ddf93.js"><link rel="prefetch" href="/coderbook/assets/js/26.4c465923.js"><link rel="prefetch" href="/coderbook/assets/js/27.7b30b08b.js"><link rel="prefetch" href="/coderbook/assets/js/28.24baedb4.js"><link rel="prefetch" href="/coderbook/assets/js/29.f282ec3c.js"><link rel="prefetch" href="/coderbook/assets/js/3.d038ebcd.js"><link rel="prefetch" href="/coderbook/assets/js/30.f7e309d4.js"><link rel="prefetch" href="/coderbook/assets/js/4.9132518f.js"><link rel="prefetch" href="/coderbook/assets/js/5.8cde2cb8.js"><link rel="prefetch" href="/coderbook/assets/js/6.cf9f53d9.js"><link rel="prefetch" href="/coderbook/assets/js/7.a256c028.js"><link rel="prefetch" href="/coderbook/assets/js/8.2227699c.js"><link rel="prefetch" href="/coderbook/assets/js/9.fbfe90ec.js">
    <link rel="stylesheet" href="/coderbook/assets/css/0.styles.b2da8d00.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/coderbook/" class="home-link router-link-active"><!----> <span class="site-name">CoderBook</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/coderbook/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/coderbook/es6/index.html" class="nav-link">
  ElasticSearch6.x
</a></div><div class="nav-item"><a href="/coderbook/redis5/index.html" class="nav-link">
  Redis5.x
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/coderbook/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/coderbook/es6/index.html" class="nav-link">
  ElasticSearch6.x
</a></div><div class="nav-item"><a href="/coderbook/redis5/index.html" class="nav-link">
  Redis5.x
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/coderbook/redis5/" class="sidebar-link">写在前面的话</a></li><li><a href="/coderbook/redis5/chapter1.html" class="sidebar-link">准备工作</a></li><li><a href="/coderbook/redis5/chapter2.html" class="sidebar-link">数据类型</a></li><li><a href="/coderbook/redis5/chapter3.html" class="sidebar-link">命令</a></li><li><a href="/coderbook/redis5/chapter4.html" class="active sidebar-link">配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coderbook/redis5/chapter4.html#持久化" class="sidebar-link">持久化</a></li><li class="sidebar-sub-header"><a href="/coderbook/redis5/chapter4.html#主从复制" class="sidebar-link">主从复制</a></li></ul></li><li><a href="/coderbook/redis5/chapter5.html" class="sidebar-link">Java客户端（上）</a></li><li><a href="/coderbook/redis5/chapter6.html" class="sidebar-link">事务</a></li><li><a href="/coderbook/redis5/chapter7.html" class="sidebar-link">分布式锁</a></li><li><a href="/coderbook/redis5/chapter8.html" class="sidebar-link">Java客户端（下）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="配置"><a href="#配置" class="header-anchor">#</a> 配置</h1> <p>redis除了支持多种多样的存储类型，还有一点也非常重要，那就是尽管它是基于内存的存储系统，但它也能进行数据的持久化操作。这一点，对于缓存不幸宕机想恢复缓存数据时相当有效。同样，我们实际使用redis时，为了更高的性能和更高的可用性会将redis配置为集群主从模式。本章节重点介绍持久化和主从复制的相关配置。</p> <h2 id="持久化"><a href="#持久化" class="header-anchor">#</a> 持久化</h2> <p>redis的持久化有两种方式：<strong>快照持久化（RDB）<strong>和</strong>AOF持久化</strong>。</p> <h3 id="快照持久化（rdb）"><a href="#快照持久化（rdb）" class="header-anchor">#</a> 快照持久化（RDB）</h3> <p>快照持久化，是在某一时刻的所有数据写入到硬盘中持久化。显然，这存在一个“何时”写入硬盘的问题。如果相隔时间过长，那么恰好在没有持久化前宕机，这部分数据就会丢失。也就是说，无论如何配置持久化的时机，都有可能存在丢失数据的风险。所以，<strong>快照持久化适用于即使丢失一部分数据也不会造成问题的场景</strong>。</p> <p>配置快照持久化，既可以直接通过<strong>命令</strong>，也可以通过<strong>配置文件</strong>的方式。</p> <h4 id="配置文件"><a href="#配置文件" class="header-anchor">#</a> 配置文件</h4> <p>回到我们redis的安装位置，根据<strong>第一章准备工作</strong>，redis安装在<code>/usr/local/redis-5.0.7</code>路径，修改<code>redis.conf</code>配置文件。在配置文件中包含了持久化的相关配置、模板插件、lua脚本等等，我们提取出关于快照持久化相关的配置信息。</p> <div class="language- extra-class"><pre class="language-text"><code>################################ SNAPSHOTTING  ################################

# save [seconds] [changes] 表示在[seconds]秒内有[changes]个键值的变化则进行持久化。可同时配置多个，满足一个条件则触发。
save 900 1				#在900秒内有1次键值变化则进行持久化。
save 300 10				#在300秒内有10次键值变化则进行持久化。
save 60 10000			#在60秒内有10000次键值变化则进行持久化。

stop-writes-on-bgsave-error yes		#当持久化出现错误时，是否停止数据写入，默认停止数据写入。可配置为no，当持久化出现错误时，仍然能继续写入缓存数据。

rdbcompression yes		#是否压缩数据，默认压缩。可配置为no，不压缩。

rdbchecksum yes				#对持久化rdb文件是否进行校验，默认校验。可配置为no，不校验。

dbfilename dump.rdb		#指定rdb保存到本地的文件名。

dir ./								#指定rdb保存的目录，默认在本目录下，即redis的安装目录。
</code></pre></div><p>在redis中，持久化默认使用<strong>快照持久化</strong>方式，如果想要开启AOF持久化<code>appendonly yes</code>，下文会讲AOF持久化的配置。</p> <p><strong>注意，尽管这是redis安装目录下默认的配置文件，但我们在启动时需要制定配置文件的路径。如果在启动时使用<code>redis-server</code>则会有以下提示：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>10768:C 08 Feb 2020 19:52:40.149 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
</code></pre></div><p>所以我们终止redis服务，并在配置文件中增加一条<code>save 10 1</code>“在10秒内有1次键值变化则持久化”配置，指定redis安装目录下的配置文件。</p> <div class="language- extra-class"><pre class="language-text"><code>okevindeMacBook-Air:redis-5.0.7 okevin$ redis-server redis.conf 
14206:C 11 Feb 2020 23:58:52.589 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
14206:C 11 Feb 2020 23:58:52.589 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=14206, just started
14206:C 11 Feb 2020 23:58:52.589 # Configuration loaded
</code></pre></div><p>可以看到，安装目录下的配置文件加载成功。</p> <p>接下来我们来验证redis是否是“在10秒内有1次键值变化则持久化”，我们通过<code>redis-cli</code>进入redis命令行交互，并且写入一条数据。在redis的启动窗口出现了以下日志内容：</p> <div class="language- extra-class"><pre class="language-text"><code>14234:M 12 Feb 2020 00:02:13.016 * 1 changes in 10 seconds. Saving...
14234:M 12 Feb 2020 00:02:13.017 * Background saving started by pid 14235
14235:C 12 Feb 2020 00:02:13.020 * DB saved on disk
14234:M 12 Feb 2020 00:02:13.121 * Background saving terminated with success
</code></pre></div><p>这表示配置生效了。</p> <p>直接修改配置文件的方式需要重启redis服务，我们可以直接通过命令<strong>动态</strong>修改配置：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; config set save &quot;5 1&quot;
OK
</code></pre></div><p>此时写入一条数据，并在redis的启动窗口验证：</p> <div class="language- extra-class"><pre class="language-text"><code>14206:M 12 Feb 2020 00:04:26.133 * 1 changes in 5 seconds. Saving...
14206:M 12 Feb 2020 00:04:26.134 * Background saving started by pid 14237
14232:C 12 Feb 2020 00:04:26.139 * DB saved on disk
14206:M 12 Feb 2020 00:04:26.238 * Background saving terminated with success
</code></pre></div><p>可见，我们已经动态地修改了快照持久化的配置。不过这种动态配置的方式当在redis重启后将会失效。</p> <h4 id="命令"><a href="#命令" class="header-anchor">#</a> 命令</h4> <p>除了通过配置文件的方式快照持久化，我们还可以通过命令的方式“随时”地进行快照持久化，有两个命令可供使用：<code>bgsave</code>和<code>save</code>。</p> <p><code>bgsave</code>，redis会创建一个子进程，通过子进程将快照写入硬盘，父进程则继续处理命令请求。</p> <p>在redis客户端使用<code>bgsave</code>命令：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; bgsave
Background saving started
</code></pre></div><p>在redis服务端的日志：</p> <div class="language- extra-class"><pre class="language-text"><code>14234:M 12 Feb 2020 00:15:11.943 * Background saving started by pid 14245
14245:C 12 Feb 2020 00:15:11.948 * DB saved on disk
14234:M 12 Feb 2020 00:15:12.031 * Background saving terminated with success
</code></pre></div><p><code>save</code>则是redis在快照创建完成前不会响应其他命令，也就是阻塞式的，并不常用。</p> <p>在redis客户端使用<code>save</code>命令：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; save
OK
</code></pre></div><p>在redis服务端的日志：</p> <div class="language- extra-class"><pre class="language-text"><code>14234:M 12 Feb 2020 00:16:12.922 * DB saved on disk
</code></pre></div><p>通过redis服务端的日志我们就能发现，配置文件中的save配置底层调用的是<code>bgsave</code>命令。那么什么时候会用到<code>save</code>命令呢？</p> <p>那就是在调用<code>shutdown</code>命令时，将会调用<code>save</code>命令阻塞其他命令，当执行完成后关闭服务器。</p> <p>在redis客户端调用<code>shutdown</code>命令：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; shutdown
</code></pre></div><p>在redis服务端的日志：</p> <div class="language- extra-class"><pre class="language-text"><code>14234:M 12 Feb 2020 00:18:52.353 # User requested shutdown...
14234:M 12 Feb 2020 00:18:52.353 * Saving the final RDB snapshot before exiting.
14234:M 12 Feb 2020 00:18:52.356 * DB saved on disk
14234:M 12 Feb 2020 00:18:52.356 * Removing the pid file.
14234:M 12 Feb 2020 00:18:52.357 # Redis is now ready to exit, bye bye...
</code></pre></div><h3 id="aof持久化"><a href="#aof持久化" class="header-anchor">#</a> AOF持久化</h3> <p>AOF持久化的方式和MySQL中binlog主从同步类似，它记录的是<strong>执行的命令</strong>，将被执行的写命令写入到AOF文件的末尾。它同样有持久化时机的问题，通常我们会配置“每秒执行一次同步”。下面我们仍然通过配置来直观感受一下。</p> <h4 id="配置文件-2"><a href="#配置文件-2" class="header-anchor">#</a> 配置文件</h4> <div class="language- extra-class"><pre class="language-text"><code>############################## APPEND ONLY MODE ###############################

appendonly no			#是否开起AOF持久化，默认关闭，yes打开。在redis4.0以前不允许混合使用RDB和AOF，但此后允许使用混合模式，通过最后两个参数配置。

appendfilename &quot;appendonly.aof&quot;			#AOF持久化数据的文件名。

appendfsync everysec		#执行AOF持久化的频率，默认“每秒执行一次同步”。还有“always”选项，表示每个redis命令都要同步写入硬盘，但是这样会严重减低redis的速度。还有“no”选项，此时持久化的时机将有操作系统决定。redis建议如果你不知道怎么做，就使用“everysec”配置。

no-appendfsync-on-rewrite no		#默认不重写AOF文件。

#下面这两个配置是用于AOF“重写”触发条件。当AOF文件的体积大于64m，且AOF文件的体积比上一次重写之后的体积至少打了一倍（100%）则执行重新命令。
auto-aof-rewrite-percentage 100		
auto-aof-rewrite-min-size 64mb	

aof-load-truncated yes			#指redis在恢复时，会忽略最后一条可能存在问题的指令，默认值yes。

aof-use-rdb-preamble yes		#是否打开RDB和AOF混合模式，默认yes打开。
</code></pre></div><p>我们修改配置文件中<code>appendonly yes</code>即打开AOF持久化，并重启redis服务。</p> <p>和快照持久化略微不同的是我们在<code>redis-cli</code>中写入一条数据后，redis服务端并没有记录AOF的持久化日志。但我们在启动时，会出现从AOF文件中加载数据。</p> <div class="language- extra-class"><pre class="language-text"><code>15336:M 12 Feb 2020 14:21:42.541 # Server initialized
15336:M 12 Feb 2020 14:21:42.542 * DB loaded from append only file: 0.001 seconds
15336:M 12 Feb 2020 14:21:42.542 * Ready to accept connections
</code></pre></div><p>如果我们此时关闭redis服务端再启动，由于我们开启了持久化所以仍然能获取到刚刚写入的值。</p> <p>和快照持久化相同，我们同样能在命令行中通过<code>config set appendonly &quot;yes&quot;</code>动态修改配置文件。</p> <p><strong>在前面的配置文件中，我们提到了“重写”这个术语，它实际上是针对AOF文件过大，需要覆盖掉之前的AOF文件的配置。它和<code>bgsave</code>类似，都是通过一个子进程操作。</strong></p> <h2 id="主从复制"><a href="#主从复制" class="header-anchor">#</a> 主从复制</h2> <p>对于一个使用了redis的大型应用程序，为了保证redis的性能，我们会配置redis集群。同MySQL类似，redis的主服务器（master）也会向多个从服务器（slave）发送更新。主服务器负责写、从服务器负责读，以提高性能。</p> <p>这一小节，我会找到另外一台mac实体机在同一局域网内实现redis主从复制，当然你也可以在虚拟机中试验。</p> <p><img src="resources/redis-master-slave.png" alt="master-slave"></p> <p>修改master主服务器的配置文件（为了更好演示主从复制，将尽可能做更少的配置）：</p> <div class="language- extra-class"><pre class="language-text"><code>#bind 127.0.0.1			#默认只允许本机连接redis服务，所以需要注释掉这行配置。
protected-mode no		#默认打开了保护模式，这里我们配置为no关闭。
daemonize no				#实际应用中，我们是通常是将redis以后台运行，也就是会配置为yes，默认是no表示不以后台运行。我们在这里保持默认的配置，方便查看相关的运行日志。
</code></pre></div><p>修改slave从服务器的配置文件（只比master多一行配置）：</p> <div class="language- extra-class"><pre class="language-text"><code>#bind 127.0.0.1			#默认只允许本机连接redis服务，所以需要注释掉这行配置。
protected-mode no		#默认打开了保护模式，这里我们配置为no关闭。
daemonize no				#实际应用中，我们是通常是将redis以后台运行，也就是会配置为yes，默认是no表示不以后台运行。我们在这里保持默认的配置，方便查看相关的运行日志。

slaveof 192.168.31.125 6379
</code></pre></div><p>我们先启动master主服务器显示以下信息：</p> <div class="language- extra-class"><pre class="language-text"><code>okevindeMacBook-Air:redis-5.0.7 okevin$ redis-server redis.conf 
15702:C 12 Feb 2020 22:18:24.777 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
15702:C 12 Feb 2020 22:18:24.778 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=15702, just started
15702:C 12 Feb 2020 22:18:24.778 # Configuration loaded
15702:M 12 Feb 2020 22:18:24.781 * Increased maximum number of open files to 10032 (it was originally set to 2560).
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 5.0.7 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 15702
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

15702:M 12 Feb 2020 22:18:24.801 # Server initialized
15702:M 12 Feb 2020 22:18:24.803 * DB loaded from append only file: 0.002 seconds
15702:M 12 Feb 2020 22:18:24.803 * Ready to accept connections
</code></pre></div><p>再启动slave从服务器显示以下信息：</p> <div class="language- extra-class"><pre class="language-text"><code>t4f-mbp-17346:redis-5.0.7 yulinfeng$ redis-server redis.conf 
13801:C 12 Feb 2020 22:20:08.954 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
13801:C 12 Feb 2020 22:20:08.954 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=13801, just started
13801:C 12 Feb 2020 22:20:08.954 # Configuration loaded
13801:S 12 Feb 2020 22:20:08.955 * Increased maximum number of open files to 10032 (it was originally set to 256).
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 5.0.7 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 13801
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

13801:S 12 Feb 2020 22:20:08.956 # Server initialized
13801:S 12 Feb 2020 22:20:08.956 * Ready to accept connections
13801:S 12 Feb 2020 22:20:08.957 * Connecting to MASTER 192.168.31.145:6379
13801:S 12 Feb 2020 22:20:08.965 * MASTER &lt;-&gt; REPLICA sync started
13801:S 12 Feb 2020 22:20:09.030 * Non blocking connect for SYNC fired the event.
13801:S 12 Feb 2020 22:20:09.034 * Master replied to PING, replication can continue...
13801:S 12 Feb 2020 22:20:09.039 * Partial resynchronization not possible (no cached master)
13801:S 12 Feb 2020 22:20:09.043 * Full resync from master: b7b0b93ea396930cc622250b959fd9eb8eb71c5f:0
13801:S 12 Feb 2020 22:20:09.138 * MASTER &lt;-&gt; REPLICA sync: receiving 185 bytes from master
13801:S 12 Feb 2020 22:20:09.139 * MASTER &lt;-&gt; REPLICA sync: Flushing old data
13801:S 12 Feb 2020 22:20:09.139 * MASTER &lt;-&gt; REPLICA sync: Loading DB in memory
13801:S 12 Feb 2020 22:20:09.139 * MASTER &lt;-&gt; REPLICA sync: Finished with success
</code></pre></div><p>可以看到从服务器在启动完成后多了一些日志，第一行<code>MASTER &lt;-&gt; REPLICA sync started</code>向主服务器发送了同步的命令，一直到最后同步成功。</p> <p>我们回到master主服务的日志：</p> <div class="language- extra-class"><pre class="language-text"><code>15702:M 12 Feb 2020 22:20:09.010 * Replica 192.168.31.215:6379 asks for synchronization
15702:M 12 Feb 2020 22:20:09.010 * Full resync requested by replica 192.168.31.215:6379
15702:M 12 Feb 2020 22:20:09.010 * Starting BGSAVE for SYNC with target: disk
15702:M 12 Feb 2020 22:20:09.011 * Background saving started by pid 15703
15703:C 12 Feb 2020 22:20:09.014 * DB saved on disk
15702:M 12 Feb 2020 22:20:09.106 * Background saving terminated with success
15702:M 12 Feb 2020 22:20:09.106 * Synchronization with replica 192.168.31.215:6379 succeeded
</code></pre></div><p>可以看到，第一行表示有一台从服务器正在请求同步，并且观察日志可以发现主服务器此时执行了<code>bgsave</code>命令进行了一次持久化操作。</p> <p>此时，当我们在主服务写入一条数据时，在从服务器就可以读取到了。但是，如果我们在从服务器写入数据时会出现以下错误：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; set slave master
(error) READONLY You cant't write against a read only replica.
</code></pre></div><p><strong>回顾主从复制中的一些细节，除了配置文件需要有注意的地方，在底层当从服务器连接到主服务器时会发送一条<code>sync</code>同步命令，当主服务器接收到从服务器的<code>sync</code>同步命令后，会在主服务器中执行<code>bgsave</code>持久化命令，执行完成后将向从服务器发送一份快照持久化的文件以完成同步。并且从服务器是只读不能写入的。</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/coderbook/redis5/chapter3.html" class="prev">
        命令
      </a></span> <span class="next"><a href="/coderbook/redis5/chapter5.html">
        Java客户端（上）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/coderbook/assets/js/app.bd0e8773.js" defer></script><script src="/coderbook/assets/js/2.2e9b2f22.js" defer></script><script src="/coderbook/assets/js/23.d28e9e5c.js" defer></script>
  </body>
</html>
