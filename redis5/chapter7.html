<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>分布式锁 | CoderBook</title>
    <meta name="description" content="CoderBook">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/coderbook/assets/css/0.styles.b2da8d00.css" as="style"><link rel="preload" href="/coderbook/assets/js/app.bd0e8773.js" as="script"><link rel="preload" href="/coderbook/assets/js/2.2e9b2f22.js" as="script"><link rel="preload" href="/coderbook/assets/js/26.4c465923.js" as="script"><link rel="prefetch" href="/coderbook/assets/js/10.6f377ed6.js"><link rel="prefetch" href="/coderbook/assets/js/11.f34c1c50.js"><link rel="prefetch" href="/coderbook/assets/js/12.d8b974da.js"><link rel="prefetch" href="/coderbook/assets/js/13.4f10c2cc.js"><link rel="prefetch" href="/coderbook/assets/js/14.07641015.js"><link rel="prefetch" href="/coderbook/assets/js/15.11341f4e.js"><link rel="prefetch" href="/coderbook/assets/js/16.a1027f62.js"><link rel="prefetch" href="/coderbook/assets/js/17.b0b7317a.js"><link rel="prefetch" href="/coderbook/assets/js/18.42995780.js"><link rel="prefetch" href="/coderbook/assets/js/19.e405f35e.js"><link rel="prefetch" href="/coderbook/assets/js/20.f13e781b.js"><link rel="prefetch" href="/coderbook/assets/js/21.ecee6efb.js"><link rel="prefetch" href="/coderbook/assets/js/22.a5802306.js"><link rel="prefetch" href="/coderbook/assets/js/23.d28e9e5c.js"><link rel="prefetch" href="/coderbook/assets/js/24.0abc3809.js"><link rel="prefetch" href="/coderbook/assets/js/25.6a2ddf93.js"><link rel="prefetch" href="/coderbook/assets/js/27.7b30b08b.js"><link rel="prefetch" href="/coderbook/assets/js/28.24baedb4.js"><link rel="prefetch" href="/coderbook/assets/js/29.f282ec3c.js"><link rel="prefetch" href="/coderbook/assets/js/3.d038ebcd.js"><link rel="prefetch" href="/coderbook/assets/js/30.f7e309d4.js"><link rel="prefetch" href="/coderbook/assets/js/4.9132518f.js"><link rel="prefetch" href="/coderbook/assets/js/5.8cde2cb8.js"><link rel="prefetch" href="/coderbook/assets/js/6.cf9f53d9.js"><link rel="prefetch" href="/coderbook/assets/js/7.a256c028.js"><link rel="prefetch" href="/coderbook/assets/js/8.2227699c.js"><link rel="prefetch" href="/coderbook/assets/js/9.fbfe90ec.js">
    <link rel="stylesheet" href="/coderbook/assets/css/0.styles.b2da8d00.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/coderbook/" class="home-link router-link-active"><!----> <span class="site-name">CoderBook</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/coderbook/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/coderbook/es6/index.html" class="nav-link">
  ElasticSearch6.x
</a></div><div class="nav-item"><a href="/coderbook/redis5/index.html" class="nav-link">
  Redis5.x
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/coderbook/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/coderbook/es6/index.html" class="nav-link">
  ElasticSearch6.x
</a></div><div class="nav-item"><a href="/coderbook/redis5/index.html" class="nav-link">
  Redis5.x
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/coderbook/redis5/" class="sidebar-link">写在前面的话</a></li><li><a href="/coderbook/redis5/chapter1.html" class="sidebar-link">准备工作</a></li><li><a href="/coderbook/redis5/chapter2.html" class="sidebar-link">数据类型</a></li><li><a href="/coderbook/redis5/chapter3.html" class="sidebar-link">命令</a></li><li><a href="/coderbook/redis5/chapter4.html" class="sidebar-link">配置</a></li><li><a href="/coderbook/redis5/chapter5.html" class="sidebar-link">Java客户端（上）</a></li><li><a href="/coderbook/redis5/chapter6.html" class="sidebar-link">事务</a></li><li><a href="/coderbook/redis5/chapter7.html" class="active sidebar-link">分布式锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/coderbook/redis5/chapter7.html#通过redis实现分布式锁" class="sidebar-link">通过redis实现分布式锁</a></li><li class="sidebar-sub-header"><a href="/coderbook/redis5/chapter7.html#其他分布式锁" class="sidebar-link">其他分布式锁</a></li></ul></li><li><a href="/coderbook/redis5/chapter8.html" class="sidebar-link">Java客户端（下）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h1> <p>redis在我们日常开发中，除了用来做缓存提高应用程序的性能，降低数据库压力之外。可能用途最广泛地当属用redis来做<strong>分布式锁</strong>了。</p> <p>在单机中，我们要解决并发时线程安全的问题会使用JDK的<code>synchronized</code>或者<code>Lock</code>类，或者直接使用线程安全的类，例如<strong>JUC（java.util.concurrent并发包）</strong>。而在大型的应用程序中，单机部署显然不能满足我们的需求，这个时候要在分布式集群环境中对互斥资源进行控制访问，就需要使用到分布式锁。</p> <p>在本章中，我们着重介绍基于redis的分布式锁，同时将简单介绍其他分布式锁的解决方案。</p> <p>开始之前先总结无论什么方式的分布式锁，其核心都是<strong>如有不存在某个key则写入，存在则返回写入失败</strong>。</p> <h2 id="通过redis实现分布式锁"><a href="#通过redis实现分布式锁" class="header-anchor">#</a> 通过redis实现分布式锁</h2> <p>redis中主要通过<code>setnx</code>命令实现，全称是“<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists”，意为如果存在则写入。如果不存在key则返回1，已经存在了这个key，则会返回0。释放锁时直接调用<code>del</code>命令删除即可。</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; setnx redis_lock a
(integer) 1
127.0.0.1:6379&gt; setnx redis_lock a
(integer) 0
</code></pre></div><p>但是<strong>请注意</strong>，使用<code>setnx</code>有一定的风险，我们知道加锁就有存在“死锁”的可能性，而打破死锁的方法之一就是主动释放资源（设置锁过期时间），然而<code>setnx</code>并没有提供<strong>过期时间</strong>的设置，redis提供了另外一个命令——<code>expire</code>来设置key值得过期时间，所以改造上面的例子为以下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; setnx redis_lock a			#设置一个分布式锁的key为redis_lock
(integer) 1
127.0.0.1:6379&gt; expire redis_lock 5			#设置redis_lock的过期时间为5秒，到期自动删除
(integer) 1
127.0.0.1:6379&gt; setnx redis_lock a			#此时再设置分布式锁的key为redis_lock，返回0失败
(integer) 0
127.0.0.1:6379&gt; setnx redis_lock a			#过5秒再设置分布式锁的key为redis_lock，返回1成功
(integer) 1
</code></pre></div><p>可以看到通过组合<code>setnx</code>和<code>expire</code>命令，能达到我们想要的结果。但是<strong>请注意</strong>，它仍然存在一个问题，那就是这两个命令并不是原子性的，如果在执行<code>expire redis_lock 5</code>时，redis服务恰好宕机，此时这个key将会一直存在。</p> <p>好在redis为我们提供了<code>set</code>命令的分布式用法并且可以设置为过期时间，关键是原子性的。官方的命令参数为<code>set key value [expiration EX seconds|PX milliseconds] [NX|XX]</code>。</p> <p><code>[expiration EX seconds|PX milliseconds]</code>参数EX表示过期时间单位为“秒”，PX表示过期时间单位为“毫秒”。</p> <p><code>[NX|XX]</code>参数NX表示“<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists”不存在则写入，XX表示“<strong>SET</strong> if e<strong>X</strong>ists”存在则写入，分布式锁的场景中使用“NX”参数。</p> <p>所以我们设置一个key值名为“lock”的锁，5秒后自动删除：</p> <div class="language- extra-class"><pre class="language-text"><code>127.0.0.1:6379&gt; set lock a ex 5 nx			#设置一个key值名为“lock”的锁，5秒后自动删除
OK
127.0.0.1:6379&gt; set lock a ex 5 nx			#5秒内设置一个key值名为“lock”的锁，5秒后自动删除。返回nil失败
(nil)
127.0.0.1:6379&gt; set lock a ex 5 nx			#5秒后设置一个key值名为“lock”的锁，5秒后自动删除。返OK成功
OK
</code></pre></div><p>使用redis作为分布式锁，最好要设置<strong>过期时间</strong>，也就是最好使用<strong>set</strong>命令。</p> <h2 id="其他分布式锁"><a href="#其他分布式锁" class="header-anchor">#</a> 其他分布式锁</h2> <h3 id="通过zookeeper实现分布式锁"><a href="#通过zookeeper实现分布式锁" class="header-anchor">#</a> 通过ZooKeeper实现分布式锁</h3> <p>ZooKeeper是一个分布式协调服务中间件，它可以用作<strong>注册中心</strong>、<strong>动态配置中心</strong>等等。</p> <p>我们利用ZooKeeper的<strong>临时有序节点</strong>也可以实现分布式锁。</p> <p>ZooKeeper的数据结构类似Linux中的文件结构，总体来讲它时“一棵树”，节点中记录相关信息。节点分为“永久节点”和“临时节点”。当我们要获取一个锁时，需要在ZooKeeper的结构中创建一个<strong>临时有序节点</strong>，释放锁同样时删除节点。获取分布式锁，即获取一个ZooKeeper的临时有序节点，如果获取到的有序节点存在比序号比自己更小的兄弟节点，即获取锁失败。</p> <p>基于ZooKeeper实现分布式锁可以利用ZooKeeper监听的特性，一旦有节点发生变化可以进行通知。这点是Redis不具备的。但由于它的实现方式是创建和删除节点，所以在性能上不如redis。</p> <h3 id="通过mysql实现分布式锁"><a href="#通过mysql实现分布式锁" class="header-anchor">#</a> 通过MySQL实现分布式锁</h3> <p>通过MySQL实现分布式锁是我以前遇到的一个面试问题，思考以下实现方式：</p> <blockquote><p>在MySQL创建一个有关锁的表“tb_lock”，一共有两列，一列叫“key”并设置为<strong>唯一索引</strong>，另一列设置为“value”。</p> <p>获取锁时，通过<code>insert</code>插入一条记录，如果插入成功则获取锁成功；插入失败则获取锁失败。</p></blockquote> <p>一听，是不是觉得有点意思，好像确实能通过MySQL来实现分布式锁，这样我们就不必引入redis或ZooKeeper。那为什么我们日常开发中几乎没有人这样用过呢？实际上，MySQL实现分布式锁，它仅仅满足了<strong>控制互斥资源</strong>这一点，尽管它是最核心的，但分布式锁不仅是控制互斥资源，它还需要具备以下特性：</p> <ul><li>可设置过期时间，防止死锁</li> <li>需要具备阻塞获取锁的特性</li> <li>较高的性能和可靠性</li> <li>锁还需要可重入</li> <li>……</li></ul> <p>所以如果要使用MySQL来实现分布式锁，你需要去解决以上的问题，对于成熟的redis和ZooKeeper分布式锁方案，我们大可不必再造一个不可靠的轮子。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/coderbook/redis5/chapter6.html" class="prev">
        事务
      </a></span> <span class="next"><a href="/coderbook/redis5/chapter8.html">
        Java客户端（下）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/coderbook/assets/js/app.bd0e8773.js" defer></script><script src="/coderbook/assets/js/2.2e9b2f22.js" defer></script><script src="/coderbook/assets/js/26.4c465923.js" defer></script>
  </body>
</html>
